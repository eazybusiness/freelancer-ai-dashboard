import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List

from email_notifier import EmailSender
from openai_client import generate_bid_for_project
from store import load_seen, save_seen


GENERAL_PROFILE = (
    "Hi, I'm Nils Peters\n"
    "Full Stack Developer & Serial Entrepreneur\n\n"
    "Transforming ambitious business visions into powerful, scalable technology "
    "solutions. With expertise spanning full-stack development, mobile "
    "applications, and enterprise ERP systems, I deliver innovative digital "
    "experiences that drive measurable business growth."
)

PROFILE_SECTIONS = {
    "web": (
        "Full-Stack Excellence: Building robust web applications from concept to deployment.\n"
        "Technical Stack: Node.js, Express, React, Next.js, TypeScript, Python, Flask.\n"
        "Database Expertise: PostgreSQL, MongoDB, MySQL with optimized query design.\n"
        "API Development: RESTful APIs, GraphQL, real-time WebSocket implementations.\n"
        "Cloud & DevOps: AWS, Docker, CI/CD pipelines for scalable deployments."
    ),
    "mobile": (
        "Mobile Development: Native iOS/Android and cross-platform apps with Flutter/React Native.\n"
        "Mobile-First Design: Responsive, intuitive UI/UX following platform guidelines.\n"
        "App Store: Deployment support and basic ASO strategy.\n"
        "Offline & Sync: Robust offline functionality with seamless data sync."
    ),
    "coding": (
        "Innovation Prototyping: Rapid MVPs and proof-of-concept projects.\n"
        "Emerging Tech: AI/ML integration, automation, experimental features.\n"
        "Performance: Load testing, security reviews, and optimization.\n"
        "R&D: Exploring new frameworks and architectural patterns."
    ),
}

PROFILE_LINKS = {
    "web": "https://me.hiplus.de/categories/full-stack-web/index.html",
    "mobile": "https://me.hiplus.de/categories/mobile/index.html",
    "coding": "https://me.hiplus.de/categories/labs/index.html",
}

PROFILE_LABELS = {
    "web": "Full Stack Web & Innovation",
    "mobile": "Mobile Apps",
    "coding": "Innovation & Coding",
}


def _select_profile_key(category: str, project: Dict[str, Any]) -> str:
    """Pick a profile key (web, mobile, coding) based on analysis category and text."""

    category = (category or "").lower()
    text = (project.get("description") or "")
    text_lower = text.lower()

    if category == "mobile" or any(
        kw in text_lower for kw in ("flutter", "android", "ios", "react native")
    ):
        return "mobile"

    if any(kw in text_lower for kw in ("odoo", "erp")):
        return "coding"  # placeholder until an ERP-specific profile is added

    # Default to web for most dev projects; use coding for clearly experimental ones.
    if category in {"fullstack", "webdesign", "data", "devops"}:
        return "web"

    return "coding"


def _build_profile(profile_key: str) -> Dict[str, str]:
    return {
        "label": PROFILE_LABELS.get(profile_key, "Full Stack Developer"),
        "general": GENERAL_PROFILE,
        "section": PROFILE_SECTIONS.get(profile_key, ""),
        "link": PROFILE_LINKS.get(profile_key, "https://me.hiplus.de/categories/full-stack-web/index.html"),
    }


def _determine_milestone_size_and_count(project: Dict[str, Any]) -> Dict[str, Any]:
    budget = project.get("budget")
    avg: float | None = None
    if isinstance(budget, dict):
        minimum = budget.get("minimum")
        maximum = budget.get("maximum")
        values: List[float] = []
        for v in (minimum, maximum):
            if isinstance(v, (int, float)):
                values.append(float(v))
        if values:
            avg = sum(values) / len(values)

    size = "unknown"
    count = 3
    if avg is not None:
        if avg < 200:
            size, count = "small", 2
        elif avg < 1000:
            size, count = "medium", 3
        else:
            size, count = "large", 4
    else:
        size, count = "unknown", 3

    return {"size": size, "count": count}


def _build_email_bodies(result_payload: Dict[str, Any]) -> tuple[str, str]:
    """Build plain text and HTML email bodies summarizing generated bids."""

    generated = result_payload.get("generated_bids") or []
    if not isinstance(generated, list):
        generated = []

    plain_lines: List[str] = []
    html_lines: List[str] = []

    count = len(generated)
    plain_lines.append(f"{count} new bid draft(s) generated.")
    plain_lines.append("")

    html_lines.append("<html><body>")
    html_lines.append(
        f"<p><strong>{count} new bid draft(s) generated by your Freelancer AI assistant.</strong></p>"
    )

    for item in generated:
        if not isinstance(item, dict):
            continue
        title = item.get("title") or "(no title)"
        analysis = item.get("analysis") or {}
        bid = item.get("bid") or {}
        seo_url = item.get("seo_url") or ""
        project_url = (
            f"https://www.freelancer.com/projects/{seo_url}" if isinstance(seo_url, str) and seo_url else ""
        )
        summary = analysis.get("summary") or ""
        proposal = bid.get("proposal_text") or ""

        # Plain text section for this project
        plain_lines.append(f"Title: {title}")
        if project_url:
            plain_lines.append(f"Link: {project_url}")
        if summary:
            plain_lines.append(f"Summary: {summary}")
        plain_lines.append("Draft proposal:")
        plain_lines.append(proposal)
        plain_lines.append("-" * 60)
        plain_lines.append("")

        # HTML section for this project
        html_lines.append("<hr>")
        html_lines.append(f"<h3>{title}</h3>")
        if project_url:
            html_lines.append(
                f'<p><a href="{project_url}">{project_url}</a></p>'
            )
        if summary:
            html_lines.append(f"<p><strong>Summary:</strong> {summary}</p>")
        if proposal:
            html_lines.append("<p><strong>Draft proposal:</strong></p>")
            for para in proposal.split("\n\n"):
                safe_para = para.replace("<", "&lt;").replace(">", "&gt;")
                html_lines.append(f"<p>{safe_para}</p>")

    html_lines.append("</body></html>")

    plain_body = "\n".join(plain_lines)
    html_body = "\n".join(html_lines)
    return plain_body, html_body


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate proposals and milestone plans for analyzed projects.",
    )
    parser.add_argument(
        "--input-json",
        required=True,
        help="Path to analysis JSON file produced by analyze_jobs.py.",
    )
    parser.add_argument(
        "--output-json",
        help="Path to write generated bids as JSON (default: data/bids_<input>.json).",
    )
    parser.add_argument(
        "--max-projects",
        type=int,
        default=3,
        help="Maximum number of projects to generate bids for (default: 3).",
    )
    parser.add_argument(
        "--min-score",
        type=int,
        default=0,
        help="Minimum rough_score to consider for bid generation (default: 0).",
    )
    parser.add_argument(
        "--model",
        help="Override expensive model name (default: OPENAI_EXPENSIVE_MODEL or gpt-4.1-mini).",
    )
    parser.add_argument(
        "--notify-email",
        action="store_true",
        help="If set, send an email summary of generated bids to NOTIFICATION_EMAIL.",
    )

    args = parser.parse_args()

    input_path = Path(args.input_json)
    if not input_path.exists():
        raise SystemExit(f"Input JSON not found: {input_path}")

    with input_path.open("r", encoding="utf-8") as f:
        payload = json.load(f)

    # Try to load the original shortlist so we can recover full project data
    # (including budget) even if it was not embedded in the analysis JSON.
    shortlist_projects_by_id: Dict[int, Dict[str, Any]] = {}
    shortlist_input = payload.get("input")
    if isinstance(shortlist_input, str) and shortlist_input:
        shortlist_path = Path(shortlist_input)
        if shortlist_path.exists():
            try:
                with shortlist_path.open("r", encoding="utf-8") as sf:
                    shortlist_payload = json.load(sf)
                projects = shortlist_payload.get("projects") or []
                if isinstance(projects, list):
                    for p in projects:
                        if not isinstance(p, dict):
                            continue
                        pid = p.get("id")
                        if isinstance(pid, int):
                            shortlist_projects_by_id[pid] = p
            except json.JSONDecodeError:
                pass

    results: List[Dict[str, Any]] = payload.get("results") or []
    if not isinstance(results, list):
        raise SystemExit("Input JSON does not contain a 'results' list.")

    # Filter by score and presence of project + analysis.
    eligible: List[Dict[str, Any]] = []
    for item in results:
        analysis = item.get("analysis") or {}
        project = item.get("project") or {}
        score = analysis.get("rough_score")
        if not isinstance(project, dict) or not isinstance(analysis, dict):
            continue
        if not isinstance(score, int):
            continue
        if score < args.min_score:
            continue
        eligible.append(item)

    if not eligible:
        print("No eligible projects found for bid generation.")
        return

    # Sort by rough_score, then automation_potential, descending.
    def sort_key(item: Dict[str, Any]) -> tuple:
        analysis = item.get("analysis") or {}
        score = analysis.get("rough_score") or 0
        auto = analysis.get("automation_potential") or 0
        return (int(score), int(auto))

    eligible.sort(key=sort_key, reverse=True)

    seen = load_seen()
    generated_bids: List[Dict[str, Any]] = []

    for item in eligible[: args.max_projects]:
        project = item.get("project") or {}
        analysis = item.get("analysis") or {}
        project_id = item.get("id")
        if not isinstance(project_id, int):
            continue

        # If the analysis JSON did not embed the full project, fall back
        # to the original shortlist payload (which contains budget, etc.).
        if not project and project_id in shortlist_projects_by_id:
            project = shortlist_projects_by_id[project_id]

        key = str(project_id)

        profile_key = _select_profile_key(str(analysis.get("category", "")), project)
        profile = _build_profile(profile_key)

        ms = _determine_milestone_size_and_count(project)

        bid = generate_bid_for_project(
            project=project,
            analysis=analysis,
            profile=profile,
            milestone_size=ms["size"],
            milestone_count=ms["count"],
            model=args.model,
        )

        generated_bids.append(
            {
                "id": project_id,
                "title": item.get("title"),
                "seo_url": item.get("seo_url"),
                "project": project,
                "analysis": analysis,
                "bid": bid,
            }
        )

        # Update seen store: mark as bid_drafted.
        seen[key] = {
            "status": "bid_drafted",
            "last_updated": payload.get("generated_at", ""),
            "analysis": analysis,
            "bid": bid,
        }

    save_seen(seen)

    if not generated_bids:
        print("No bids generated.")
        return

    # Determine default output path if not provided.
    if args.output_json:
        out_path = Path(args.output_json)
    else:
        out_dir = Path("data")
        out_dir.mkdir(parents=True, exist_ok=True)
        out_path = out_dir / f"bids_{input_path.stem}.json"

    result_payload: Dict[str, Any] = {
        "input": str(input_path),
        "generated_bids": generated_bids,
    }
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with out_path.open("w", encoding="utf-8") as f:
        json.dump(result_payload, f, ensure_ascii=False, indent=2)

    print(f"Generated {len(generated_bids)} bids. Results written to {out_path}.")

    if args.notify_email:
        notification_email = os.getenv("NOTIFICATION_EMAIL")
        if not notification_email:
            print("NOTIFICATION_EMAIL is not set; skipping email notification.")
        else:
            sender = EmailSender()
            plain_body, html_body = _build_email_bodies(result_payload)
            subject = f"[Freelance AI] {len(generated_bids)} new bid draft(s)"
            sender.send_email(
                subject=subject,
                body=plain_body,
                notification_email=notification_email,
                attachment_paths=[str(out_path)],
                html_body=html_body,
            )


if __name__ == "__main__":
    main()
