import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List

from dotenv import dotenv_values
from email_notifier import EmailSender
from openai_client import generate_bid_for_project
from store import load_seen, save_seen
from profiles import select_profile_key as _select_profile_key, get_profile as _build_profile


GENERAL_PROFILE = (
    "Hi, I'm Nils Peters\n"
    "Full Stack Developer & Serial Entrepreneur\n\n"
    "Transforming ambitious business visions into powerful, scalable technology "
    "solutions. With expertise spanning full-stack development, mobile "
    "applications, and enterprise ERP systems, I deliver innovative digital "
    "experiences that drive measurable business growth."
)


def _read_notification_email_from_env_file() -> str | None:
    """Manual fallback parser for NOTIFICATION_EMAIL from .env.

    This does not rely on python-dotenv's environment handling and instead
    reads the file directly, looking for a line starting with
    NOTIFICATION_EMAIL and splitting on '=' or ':'.
    """

    env_path = Path(__file__).resolve().parent / ".env"
    if not env_path.exists():
        return None
    try:
        with env_path.open("r", encoding="utf-8") as f:
            for raw_line in f:
                line = raw_line.strip()
                if not line or line.startswith("#"):
                    continue
                # Handle UTF-8 BOM and similar artifacts on the first line.
                if line.startswith("\ufeff"):
                    line = line.lstrip("\ufeff")
                if not line.startswith("NOTIFICATION_EMAIL"):
                    continue
                # Support KEY=VALUE or KEY: VALUE styles.
                if "=" in line:
                    _, value = line.split("=", 1)
                elif ":" in line:
                    _, value = line.split(":", 1)
                else:
                    continue
                value = value.strip().strip('"').strip("'")
                return value or None
    except OSError:
        return None

    return None


def _project_bid_count(project: Dict[str, Any]) -> int | None:
    bid_stats = project.get("bid_stats")
    if isinstance(bid_stats, dict):
        bid_count = bid_stats.get("bid_count")
        if isinstance(bid_count, int):
            return bid_count
    return None


def _project_avg_budget(project: Dict[str, Any]) -> float | None:
    budget = project.get("budget")
    if not isinstance(budget, dict):
        return None
    minimum = budget.get("minimum")
    maximum = budget.get("maximum")
    values: List[float] = []
    for v in (minimum, maximum):
        if isinstance(v, (int, float)):
            values.append(float(v))
    if not values:
        return None
    return sum(values) / len(values)


def _determine_milestone_size_and_count(project: Dict[str, Any]) -> Dict[str, Any]:
    budget = project.get("budget")
    avg: float | None = None
    if isinstance(budget, dict):
        minimum = budget.get("minimum")
        maximum = budget.get("maximum")
        values: List[float] = []
        for v in (minimum, maximum):
            if isinstance(v, (int, float)):
                values.append(float(v))
        if values:
            avg = sum(values) / len(values)

    size = "unknown"
    count = 3
    if avg is not None:
        if avg < 200:
            size, count = "small", 2
        elif avg < 1000:
            size, count = "medium", 3
        else:
            size, count = "large", 4
    else:
        size, count = "unknown", 3

    return {"size": size, "count": count}


def _build_email_bodies(result_payload: Dict[str, Any]) -> tuple[str, str]:
    """Build plain text and HTML email bodies summarizing generated bids."""

    generated = result_payload.get("generated_bids") or []
    if not isinstance(generated, list):
        generated = []

    plain_lines: List[str] = []
    html_lines: List[str] = []

    count = len(generated)
    plain_lines.append(f"{count} new bid draft(s) generated.")
    plain_lines.append("")

    html_lines.append("<html><body>")
    html_lines.append(
        f"<p><strong>{count} new bid draft(s) generated by your Freelancer AI assistant.</strong></p>"
    )

    for item in generated:
        if not isinstance(item, dict):
            continue
        title = item.get("title") or "(no title)"
        analysis = item.get("analysis") or {}
        bid = item.get("bid") or {}
        seo_url = item.get("seo_url") or ""
        project_url = (
            f"https://www.freelancer.com/projects/{seo_url}" if isinstance(seo_url, str) and seo_url else ""
        )
        summary = analysis.get("summary") or ""
        proposal = bid.get("proposal_text") or ""

        # Plain text section for this project
        plain_lines.append(f"Title: {title}")
        if project_url:
            plain_lines.append(f"Link: {project_url}")
        if summary:
            plain_lines.append(f"Summary: {summary}")
        plain_lines.append("Draft proposal:")
        plain_lines.append(proposal)
        plain_lines.append("-" * 60)
        plain_lines.append("")

        # HTML section for this project
        html_lines.append("<hr>")
        html_lines.append(f"<h3>{title}</h3>")
        if project_url:
            html_lines.append(
                f'<p><a href="{project_url}">{project_url}</a></p>'
            )
        if summary:
            html_lines.append(f"<p><strong>Summary:</strong> {summary}</p>")
        if proposal:
            html_lines.append("<p><strong>Draft proposal:</strong></p>")
            for para in proposal.split("\n\n"):
                safe_para = para.replace("<", "&lt;").replace(">", "&gt;")
                html_lines.append(f"<p>{safe_para}</p>")

    html_lines.append("</body></html>")

    plain_body = "\n".join(plain_lines)
    html_body = "\n".join(html_lines)
    return plain_body, html_body


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate proposals and milestone plans for analyzed projects.",
    )
    parser.add_argument(
        "--input-json",
        required=True,
        help="Path to analysis JSON file produced by analyze_jobs.py.",
    )
    parser.add_argument(
        "--output-json",
        help="Path to write generated bids as JSON (default: data/bids_<input>.json).",
    )
    parser.add_argument(
        "--max-projects",
        type=int,
        default=3,
        help="Maximum number of projects to generate bids for (default: 3).",
    )
    parser.add_argument(
        "--min-score",
        type=int,
        default=0,
        help="Minimum rough_score to consider for bid generation (default: 0).",
    )
    parser.add_argument(
        "--model",
        help="Override expensive model name (default: OPENAI_EXPENSIVE_MODEL or gpt-4.1-mini).",
    )
    parser.add_argument(
        "--notify-email",
        action="store_true",
        help="If set, send an email summary of generated bids to NOTIFICATION_EMAIL.",
    )

    args = parser.parse_args()

    input_path = Path(args.input_json)
    if not input_path.exists():
        raise SystemExit(f"Input JSON not found: {input_path}")

    with input_path.open("r", encoding="utf-8") as f:
        payload = json.load(f)

    # Try to load the original shortlist so we can recover full project data
    # (including budget) even if it was not embedded in the analysis JSON.
    shortlist_projects_by_id: Dict[int, Dict[str, Any]] = {}
    shortlist_input = payload.get("input")
    if isinstance(shortlist_input, str) and shortlist_input:
        shortlist_path = Path(shortlist_input)
        if shortlist_path.exists():
            try:
                with shortlist_path.open("r", encoding="utf-8") as sf:
                    shortlist_payload = json.load(sf)
                projects = shortlist_payload.get("projects") or []
                if isinstance(projects, list):
                    for p in projects:
                        if not isinstance(p, dict):
                            continue
                        pid = p.get("id")
                        if isinstance(pid, int):
                            shortlist_projects_by_id[pid] = p
            except json.JSONDecodeError:
                pass

    results: List[Dict[str, Any]] = payload.get("results") or []
    if not isinstance(results, list):
        raise SystemExit("Input JSON does not contain a 'results' list.")

    # Filter by score and presence of project + analysis.
    eligible: List[Dict[str, Any]] = []
    for item in results:
        analysis = item.get("analysis") or {}
        project = item.get("project") or {}
        score = analysis.get("rough_score")
        if not isinstance(project, dict) or not isinstance(analysis, dict):
            continue
        if not isinstance(score, int):
            continue
        if score < args.min_score:
            continue
        eligible.append(item)

    if not eligible:
        print("No eligible projects found for bid generation.")
        return

    # Sort by a composite key so that the "top N" projects are truly
    # attractive for you:
    # - highest rough_score first
    # - then higher automation_potential
    # - then higher average budget
    # - then fewer current bids (lower bid_count)
    def sort_key(item: Dict[str, Any]) -> tuple:
        analysis = item.get("analysis") or {}
        project = item.get("project") or {}

        score = analysis.get("rough_score") or 0
        auto = analysis.get("automation_potential") or 0

        avg_budget = _project_avg_budget(project) or 0.0
        bid_count = _project_bid_count(project)
        # We want fewer bids to rank higher. Since we sort with
        # reverse=True, use a negative value here so that a smaller
        # original bid_count becomes a larger sort key.
        bid_component = -bid_count if isinstance(bid_count, int) else 0

        return (int(score), int(auto), float(avg_budget), bid_component)

    eligible.sort(key=sort_key, reverse=True)

    seen = load_seen()
    generated_bids: List[Dict[str, Any]] = []

    for item in eligible[: args.max_projects]:
        project = item.get("project") or {}
        analysis = item.get("analysis") or {}
        project_id = item.get("id")
        if not isinstance(project_id, int):
            continue

        # If the analysis JSON did not embed the full project, fall back
        # to the original shortlist payload (which contains budget, etc.).
        if not project and project_id in shortlist_projects_by_id:
            project = shortlist_projects_by_id[project_id]

        key = str(project_id)

        profile_key = _select_profile_key(str(analysis.get("category", "")), project)
        profile = _build_profile(profile_key)

        ms = _determine_milestone_size_and_count(project)

        bid = generate_bid_for_project(
            project=project,
            analysis=analysis,
            profile=profile,
            milestone_size=ms["size"],
            milestone_count=ms["count"],
            model=args.model,
        )

        generated_bids.append(
            {
                "id": project_id,
                "title": item.get("title"),
                "seo_url": item.get("seo_url"),
                "project": project,
                "analysis": analysis,
                "bid": bid,
            }
        )

        # Update seen store: mark as bid_drafted.
        seen[key] = {
            "status": "bid_drafted",
            "last_updated": payload.get("generated_at", ""),
            "analysis": analysis,
            "bid": bid,
        }

    save_seen(seen)

    if not generated_bids:
        print("No bids generated.")
        return

    # Determine default output path if not provided.
    if args.output_json:
        out_path = Path(args.output_json)
    else:
        out_dir = Path("data")
        out_dir.mkdir(parents=True, exist_ok=True)
        out_path = out_dir / f"bids_{input_path.stem}.json"

    result_payload: Dict[str, Any] = {
        "input": str(input_path),
        "generated_bids": generated_bids,
    }
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with out_path.open("w", encoding="utf-8") as f:
        json.dump(result_payload, f, ensure_ascii=False, indent=2)

    print(f"Generated {len(generated_bids)} bids. Results written to {out_path}.")

    if args.notify_email:
        notification_email = os.getenv("NOTIFICATION_EMAIL")
        if not notification_email:
            # Fallback: read directly from .env using dotenv_values, in case
            # load_dotenv did not populate the process environment.
            env_path = Path(__file__).resolve().parent / ".env"
            try:
                env_values = dotenv_values(env_path)
            except Exception:
                env_values = {}
            notification_email = env_values.get("NOTIFICATION_EMAIL")

        if not notification_email:
            # Final fallback: manual .env parsing in case there are encoding
            # issues or subtle formatting differences.
            notification_email = _read_notification_email_from_env_file()

        if not notification_email:
            print("NOTIFICATION_EMAIL is not set; skipping email notification.")
        else:
            sender = EmailSender()
            plain_body, html_body = _build_email_bodies(result_payload)
            subject = f"[Freelance AI] {len(generated_bids)} new bid draft(s)"
            sender.send_email(
                subject=subject,
                body=plain_body,
                notification_email=notification_email,
                attachment_paths=[str(out_path)],
                html_body=html_body,
            )


if __name__ == "__main__":
    main()
